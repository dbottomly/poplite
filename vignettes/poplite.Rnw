\documentclass[10pt]{article}
\usepackage[margin=1.0in]{geometry}
\usepackage[utf8]{inputenc}
\usepackage[parfill]{parskip}
\SweaveOpts{keep.source=TRUE} 

\title{poplite vignette}
\author{Daniel Bottomly}
%\VignetteIndexEntry{poplite}
\begin{document}

\maketitle

\section{Introduction}

Prior to utilizing a given database in a research context, it has to be designed, scripts written to format existing data to fit into the tables, and the data has to be loaded.
The loading can be as simple as just inserting data into a given table or in addition it may need to respect columns from other tables.  The \texttt{poplite} package was developed
originally to simplify the process of population and management of SQLite databases using R.  It provides a schema object and corresponding methods which allows a user to easily
understand the database structure as well as extend or modify it.  The database can be populated using this schema and the user can specify both raw data and a transformational function
to apply prior to loading.  This functionality facilitates loading of large, non-\texttt{data.frame} type objects as is demonstrated in the 'Advanced Usage' section.  It has since also incorportated
and extended functionality from the \texttt{dplyr} package to provide a convienient query interface using \texttt{dplyr}'s verbs.  Notably, cross table queries can be carried out automatically using
the specified schema object.

\section{Basic Usage}

We will start by working through a simple example that illustrates how to use \texttt{poplite} for many common database tasks.  Our example is a set of 3 \texttt{data.frames} which consists of
randomly generated data which is meant to resemble data collected on patients in a clinical research setting.  We first load the package and the example data, going through each \texttt{data.frame}
in turn.

<<eval=TRUE, echo=TRUE>>=

library(poplite)
data(clinical)

ls()
@

The clinical \texttt{data.frame} contains information on a group of patients including sex, age, disease status as well as other variables/covariates.

<<eval=TRUE, echo=TRUE>>=

head(clinical)

@

The samples \texttt{data.frame} records whether a given patient, keyed by sample_id was observed in one of several 'waves' and whether they contributed a DNA sample.

<<eval=TRUE, echo=TRUE>>=

head(samples)

@

The dna \texttt{data.frame} provides some information (concentration in nanograms/microliter) on the DNA specimen collected from a given patient during a given wave. 

<<eval=TRUE, echo=TRUE>>=

head(dna)

@

As these data are already in table form, loading them should be relatively straightforward.  The first step is the creation of a schema object of class \texttt{TableSchemaList} whose
name may give the user some indication about its internal structure.  For \texttt{data.frames} a convience function (\texttt{makeSchemaFromData}) is provided which does some basic checks
and creates an appropriate table based on the column names and inferred types.

<<eval=TRUE, echo=TRUE>>=

sample.tracking <- makeSchemaFromData(clinical, "clinical")

try(dna.tbsl <- makeSchemaFromData(dna, "dna"))

@

The error caused by attempting to create a schema object from dna, is due to the formatting of the column name of 'ng.ul' which is a valid R name, but not a valid SQLite name.  A convienient way to
fix this is to use the \texttt{correct.df.names} function as below.

<<eval=TRUE, echo=TRUE>>=

new.dna <- correct.df.names(dna)
dna.tbsl <- makeSchemaFromData(new.dna, "dna")

sample.tracking <- append(sample.tracking, dna.tbsl)

sample.tbsl <- makeSchemaFromData(samples, "samples")

sample.tracking <- append(sample.tracking,  sample.tbsl)

@

At this point, the database can be created and populated using the schema defined in 'sample.tracking' and the data present in the respective \texttt{data.frames}.  However, this requires anyone
who wants to query across the tables be able to determine the relationships between the tables.  In some cases this can be determined by column names alone, in other cases it may not be so clear.  The \texttt{poplite}
package allows the specification of relationships between tables using the R formula syntax.  This functionality is probably best illustrated by example.

The 'clinical' table is the starting point of this database as both the 'samples' and 'dna' tables refer back to its.  In the case of both the 'dna' and 'samples' tables, the 'clinical' table can be refered to using the 'sample_id' column.
This type of relationship can be created by the following:

<<eval=TRUE, echo=TRUE>>=

relationship(sample.tracking, from="clinical", to="dna") <-sample_id~sample_id

relationship(sample.tracking, from="clinical", to="samples") <- sample_id~sample_id
@

In addition, the 'dna' table can be referred to by the 'samples' table using a combination of 'sample_id' and 'wave'.  Instead of directly cross referencing these columns as we did for 'sample_id', we specify that we want to use the 'primary key'
of 'dna'.  This is a column of integer values that uniquely identifies each row, it was added automatically by \texttt{makeSchemaFromData} by default.  We specify this in the following manner:

<<eval=TRUE, echo=TRUE>>=

relationship(sample.tracking, from="dna", to="samples") <- .~sample_id+wave

@

Where '.' indicates that the primary key for the table should be used.  Now that our schema is complete, we are now ready to populate our database.  First, we create a \texttt{Database} object which simply contains both the schema as well as
the file path to where the database resides.  We then call the \texttt{populate} method and provide it a named list containing our \texttt{data.frames}.  The database is now ready to be queried!

<<eval=TRUE, echo=TRUE>>=

sample.tracking.db <- Database(sample.tracking, tempfile())
populate(sample.tracking.db, list(dna=new.dna, samples=samples, clinical=clinical))

@

As mentioned in the introduction, the query interface utilizes the approach of the \texttt{dplyr} package, whereby several verbs are used to perform common queries.  In addition to utilizing the single table verbs defined in \texttt{dplyr}, \texttt{poplite}
defines multi-table versions of the \texttt{filter} and \texttt{select} verbs.

\begin{center}

<<fig=TRUE, echo=TRUE>>=

plot(1:10,1:10)

@

\end{center}

\section{Advanced Usage}

Featuring VCF parsing from the VariantAnnotation package

<<eval=TRUE>>=
sessionInfo()
@

\end{document}
