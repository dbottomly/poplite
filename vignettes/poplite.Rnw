\documentclass[10pt]{article}
\usepackage[margin=1.0in]{geometry}
\usepackage[utf8]{inputenc}
\usepackage[parfill]{parskip}
\SweaveOpts{keep.source=TRUE} 

\title{poplite vignette}
\author{Daniel Bottomly}
%\VignetteIndexEntry{poplite}
\begin{document}

\maketitle

\section{Introduction}

Prior to utilizing a given database in a research context, it has to be designed, scripts written to format existing data to fit into the tables, and the data has to be loaded.
The loading can be as simple as just inserting data into a given table or in addition it may need to respect columns from other tables.  The \texttt{poplite} package was developed
originally to simplify the process of population and management of SQLite databases using R.  It provides a schema object and corresponding methods which allows a user to easily
understand the database structure as well as extend or modify it.  The database can be populated using this schema and the user can specify both raw data and a transformational function
to apply prior to loading.  This functionality facilitates loading of large, non-\texttt{data.frame} type objects as is demonstrated in the 'Advanced Usage' section.  It has since also incorportated
and extended functionality from the \texttt{dplyr} package to provide a convienient query interface using \texttt{dplyr}'s verbs.  Notably, cross table queries can be carried out automatically using
the specified schema object.

\section{Basic Usage}

We will start by working through a simple example that illustrates how to use \texttt{poplite} for many common database tasks.  Our example is a set of 3 \texttt{data.frames} which consists of
randomly generated data which is meant to resemble data collected on patients in a clinical research setting.  We first load the package and the example data, going through each \texttt{data.frame}
in turn.

<<eval=TRUE, echo=TRUE>>=

library(poplite)
data(clinical)

ls()
@

The clinical \texttt{data.frame} contains information on a group of patients including sex, age, disease status as well as other variables/covariates.

<<eval=TRUE, echo=TRUE>>=

head(clinical)

@

The samples \texttt{data.frame} records whether a given patient, keyed by sample\_id was observed in one of several 'waves' and whether they contributed a DNA sample.

<<eval=TRUE, echo=TRUE>>=

head(samples)

@

The dna \texttt{data.frame} provides some information (concentration in nanograms/microliter) on the DNA specimen collected from a given patient during a given wave. 

<<eval=TRUE, echo=TRUE>>=

head(dna)

@

As these data are already in table form, loading them should be relatively straightforward.  The first step is the creation of a schema object of class \texttt{TableSchemaList} whose
name may give the user some indication about its internal structure.  For \texttt{data.frames} a convience function (\texttt{makeSchemaFromData}) is provided which does some basic checks
and creates an appropriate table based on the column names and inferred types.

<<eval=TRUE, echo=TRUE>>=

sample.tracking <- makeSchemaFromData(clinical, "clinical")

try(dna.tbsl <- makeSchemaFromData(dna, "dna"))

@

The error caused by attempting to create a schema object from dna, is due to the formatting of the column name of 'ng.ul' which is a valid R name, but not a valid SQLite name.  A convienient way to
fix this is to use the \texttt{correct.df.names} function as below.  Note that this modified \texttt{data.frame} will be the one that has to be provided to the \texttt{populate} method.

<<eval=TRUE, echo=TRUE>>=

new.dna <- correct.df.names(dna)
dna.tbsl <- makeSchemaFromData(new.dna, "dna")

sample.tracking <- append(sample.tracking, dna.tbsl)

sample.tbsl <- makeSchemaFromData(samples, "samples")

sample.tracking <- append(sample.tracking,  sample.tbsl)

@

At this point, the database can be created and populated using the schema defined in 'sample.tracking' and the data present in the respective \texttt{data.frames}.  However, this requires anyone
who wants to query across the tables be able to determine the relationships between the tables.  In some cases this can be determined by column names alone, in other cases it may not be so clear.  The \texttt{poplite}
package allows the specification of relationships between tables using the R formula syntax.  This functionality is probably best illustrated by example.

The 'clinical' table is the starting point of this database as both the 'samples' and 'dna' tables refer back to its.  In the case of both the 'dna' and 'samples' tables, the 'clinical' table can be refered to using the 'sample\_id' column.
This type of relationship can be created by the following:

<<eval=TRUE, echo=TRUE>>=

relationship(sample.tracking, from="clinical", to="dna") <-sample_id~sample_id

relationship(sample.tracking, from="clinical", to="samples") <- sample_id~sample_id
@

In addition, the 'dna' table can be referred to by the 'samples' table using a combination of 'sample\_id' and 'wave'.  Instead of directly cross referencing these columns as we did for 'sample\_id', we specify that we want to use the 'primary key'
of 'dna'.  Where the primary key is a column of integer values that uniquely identifies each row and by default it was added automatically by \texttt{makeSchemaFromData}.  We specify this in the following manner:

<<eval=TRUE, echo=TRUE>>=

relationship(sample.tracking, from="dna", to="samples") <- .~sample_id+wave

@

Where '.' is a shortcut that indicates that the primary key for the table should be used.  Now that our schema is complete, we are now ready to populate our database.  First, we create a \texttt{Database} object which simply contains both the schema as well as
the file path to where the database resides.  We then call the \texttt{populate} method and provide it a named list containing our \texttt{data.frames}.  The database is now ready to be queried!

<<eval=TRUE, echo=TRUE>>=

sample.tracking.db <- Database(sample.tracking, tempfile())
populate(sample.tracking.db, list(dna=new.dna, samples=samples, clinical=clinical))

@

As mentioned in the introduction, the query interface utilizes the approach of the \texttt{dplyr} package, whereby a small set of verbs are used to perform common queries.  In addition to utilizing the single table verbs defined in \texttt{dplyr}, \texttt{poplite}
defines multi-table versions of the \texttt{select} and \texttt{filter} verbs.  The \texttt{select} verb allows the user to select columns from a table-like object, in this case an SQLite database. As the \texttt{poplite} version of \texttt{select} and \texttt{filter} can be used for any of the
tables in the defined schema, the most important requirement is for the user to make sure the column(s) are unambigous in terms of the tables.  This can be done in several ways:

(1) Only for the \texttt{select} statement, the \texttt{.tables} argument allows selecting all or part of the columns of a given table(s).  If multiple tables are provided, then they are first joined (an 'inner join' in SQL terminology) using the specified relationships in the schema.  This provides a convienent
way to retrieve a combined version of the data in the database.

<<eval=TRUE, echo=TRUE>>=

select(sample.tracking.db, .tables="dna")

select(sample.tracking.db, sample_id:lab_id, .tables="dna")

select(sample.tracking.db, .tables=c("clinical","dna"))

@

(2) If a column or set of columns uniquely identifies a table, then no further information is needed to execute the query.

<<eval=TRUE, echo=TRUE>>=

select(sample.tracking.db, sample_id:lab_id)

filter(sample.tracking.db, sex == "M" & var_wave_1 > 0)

filter(sample.tracking.db, sample_id == 97 & var_wave_1 > 0)

try(filter(sample.tracking.db, sample_id == 97))

@

(3) A table can be specified in the query using a '.' similar to how it is done in SQL, i.e. tableX.ColumnY.  This only should be done once per statement for \texttt{select} statments, but per variable for filter statements as is shown below.
This restriction reflects how the queries are carried out.  Each grouping of statements statements are applied to the specified or inferred table prior to joining.  Note that for the \texttt{poplite} \texttt{filter} verb cross-table 'OR' statements are currently not
supported.

<<eval=TRUE, echo=TRUE>>=


select(sample.tracking.db, dna.sample_id)

select(sample.tracking.db, dna.sample_id:lab_id)

filter(sample.tracking.db, clinical.sample_id == 97)

filter(sample.tracking.db, clinical.status == 1 & dna.wave==2)

@

The \texttt{poplite} query interface is opt-in meaning that more complex queries can always be carried out directly using the methodology provided in the \texttt{dplyr} package or plain SQL statements after first connecting to the database file using RSQLite.
Below are three approaches of performing the same query:

<<eval=TRUE, echo=TRUE>>=

#poplite + dplyr
wave.1.samp.pop <- filter(select(sample.tracking.db, .tables=c("samples", "dna")), wave == 1)

#dplyr
src.db <- src_sqlite(dbFile(sample.tracking.db), create = F)
samp.tab <- tbl(src.db, "samples")
dna.tab <- tbl(src.db, "dna")
wave.1.samp.dplyr <- inner_join(samp.tab, filter(dna.tab, wave == 1), by=c("dna_ind", "sample_id"))

#RSQLite
samp.db <- dbConnect(SQLite(), dbFile(sample.tracking.db))
wave.1.samp.sql <- dbGetQuery(samp.db, 'SELECT * FROM samples JOIN dna USING (dna_ind, sample_id) WHERE wave == 1')
dbDisconnect(samp.db)

all.equal(as.data.frame(wave.1.samp.pop), wave.1.samp.sql)

all.equal(as.data.frame(wave.1.samp.dplyr), wave.1.samp.sql)

@

\section{Advanced Usage}

Featuring VCF parsing from the VariantAnnotation package

\begin{center}

<<fig=TRUE, echo=TRUE>>=

plot(1:10,1:10)

@

\end{center}





<<eval=TRUE>>=
sessionInfo()
@

\end{document}
